<!DOCTYPE HTML><html>
<head><meta charset="utf-8"><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" rel="stylesheet"><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body><div class="container"><div class="row"><div class="col-sm-12">
<h1>Segmentation</h1>
<p>This module comprises the segmentation part of the preprocessing of the data, applying whats
described in the paper</p>
<blockquote>
<p><strong>Automatic segmentation of Phonocardiogram using the occurrence of the cardiac events</strong>
<em>Vishwanath et al., 2017</em></p>
</blockquote>
<p><em>Required libraries</em>:</p>
<pre class="haskell"><code>import Sound.File.Sndfile            as Snd
import Sound.File.Sndfile.Buffer.StorableVector as BV
import Data.Complex                  as Complex
import Data.Array                    as Array
import qualified Data.StorableVector as Vector
import DSP.Basic                     as DSP
import DSP.Window                    as DSP
import DSP.Filter.IIR.IIR            as DSP
import DSP.Filter.IIR.Design         as DSP
import Numeric.Transform.Fourier.FFT as FFT
import Graphics.Plotly               as Plotly
import Graphics.Plotly.Lucid         as Plotly
import Lucid                         as Lucid
import qualified Data.Text           as Text
import Data.StorableVector (Vector)
import Data.Function ((&amp;))
import Data.Text (Text)
import Data.Monoid
</code></pre>
<h2>1. Process</h2>
<p>The process that is described in the paper can be mapped to the following commutative diagram:</p>
<p>$$\require{AMScd}$$</p>
<p>$$\begin{CD}
Noisy Sound @&gt;prefilter&gt;&gt; Filtered Sound @&gt;makeSpectrogram&gt;&gt; Spectrogram\\
@. @. @VV{barkscale}V\\
Event Detection Function @&lt;loudnessEvaluation&lt;&lt; SmoothSpectrogram @&lt;smoothen&lt;&lt; BarkScaled Spectrogram
\end{CD}$$</p>
<p>The <a href="https://en.wikipedia.org/wiki/Class_(set_theory)">classes</a>
in this commutative diagram can be represented directly as newtypes in Haskell:</p>
<pre class="haskell"><code>newtype NoisySound             = NoisySound [Double]
newtype FilteredSound          = FilteredSound [Double]
newtype Spectrogram            = Spectrogram [Array Int Double]
newtype BarkScaledSpectrogram  = BarkScaledSpectrogram [Array Int Double]
newtype SmoothSpectrogram      = SmoothSpectrogram [Array Int Double]
newtype EventDetectionFunction = EventDetectionFunction [Double]
</code></pre>
<p>The <a href="https://en.wikipedia.org/wiki/Morphism">morphisms</a> represented in the diagram are functions
that would transform the data in some way:</p>
<ol>
<li><code>prefilter</code> would apply a <a href="https://en.wikipedia.org/wiki/Chebyshev_filter">Chebyshev type I Lowpass filter</a></li>
<li>An <code>stft</code> would be applied to all the <code>FilteredSound</code> using a <em>3ms</em> <a href="https://en.wikipedia.org/wiki/Window_function#Cosine-sum_windows">Hann Window</a></li>
<li><code>barkscale</code> scales the <code>Spectrogram</code> using a <a href="https://en.wikipedia.org/wiki/Bark_scale">Bark scale</a></li>
<li><code>smoothen</code> convolves each of the frequency bands using a <em>200ms</em> Hanning window.</li>
<li><code>loudnessEvaluation</code> sums all the amplitudes of all frequency bands</li>
<li>Now we convolute the loudness with a <em>300ms</em> Hamming window, so we obtain a smoothed loudness
index function, where positive peaks are <strong>onsets</strong>, and negative ones are <strong>offsets</strong></li>
</ol>
<p>After doing this process, we can locate manually the \(S_1\) and \(S_2\) sounds, which help us
to locate the <em>systole</em> and <em>diastole</em>. After that, it&#39;s just a matter of alternation. So, we
can automate the segmentation of the next sounds.</p>
<h2>2. Implementation</h2>
<p>To implement the <code>prefilter</code> function, we can use the <code>dsp</code> package that comes with many
nice DSP functions that are helpful here.</p>
<pre class="haskell"><code>prefilter :: NoisySound -&gt; FilteredSound
prefilter (NoisySound ns) = FilteredSound filteredSound
  where
    wp = 0.5
    rp = 0.05
    ws = 0
    rs = 0.05
    (b, a) = DSP.chebyshev1Lowpass (wp, rp) (ws, rs)
    filteredSound = DSP.iir_df2 (b, a) ns
</code></pre>
<p>Now we can proceed to define <code>makeSpectrogram</code>, but first we need to separate all of our
samples in frames, and get their magnitudes:</p>
<pre class="haskell"><code>getFrames :: Array Int Double -&gt; Int -&gt; Int -&gt; [Array Int Double]
getFrames inArr frameSize hop =
     [getFrame inArr start frameSize | start &lt;- [0, hop .. l-1]]
   where
     (_,l) = Array.bounds inArr
 
getFrame :: Array Int Double -&gt; Int -&gt; Int -&gt; Array Int Double
getFrame inVect start len =
    DSP.pad slice len
  where
    slice = Array.ixmap (0, l - 1) (+ start) inVect
    l = min len (end - start)
    (_,end) = Array.bounds inVect

getFrameMagnitude :: Array Int (Complex Double) -&gt; Array Int Double
getFrameMagnitude frame =
        Array.array (0,(l-1) `div` 2) 
            [(i,log (magnitude (frame!(i+(l-1) `div` 2)) + 1))
                | i &lt;- [0..((l-1) `div` 2)]]
    where
        (_,l) = Array.bounds frame
</code></pre>
<p>Now, we define our <code>makeSpectrogram</code> function easily:</p>
<pre class="haskell"><code>makeSpectrogram :: FilteredSound -&gt; Spectrogram
makeSpectrogram (FilteredSound fs) = Spectrogram spectrogram
  where
    fsArray = Array.array (0, length fs) [(i, fs !! i) | i &lt;- [0..length fs]]
    spectrogram = map (getFrameMagnitude . rfft) (getFrames fsArray 1024 512)
</code></pre>
<p>To make the <code>barkscale</code> function we just have to apply the following function to each
of the frequencies in our <code>Spectrogram</code>:</p>
<p>$$ z(f) = 13\ arctan(0.00076f)+3.5arctan(\frac{f}{7500^2}) $$</p>
<pre class="haskell"><code>barkscaleFrequency :: Double -&gt; Double
barkscaleFrequency f = 13.0 * atan (0.00076 * f) + 3.5 * atan (f/(7500^2))
</code></pre>
<p>For scaling our spectrogram, it is a matter of applying the function two levels deep
elementwise using <code>fmap</code>:</p>
<pre class="haskell"><code>barkscale :: Spectrogram -&gt; BarkScaledSpectrogram
barkscale (Spectrogram s) =
    BarkScaledSpectrogram $ (fmap . fmap) barkscaleFrequency s
</code></pre>
<p>Let&#39;s smoothen the spectrogram by using a hann window:</p>
<pre class="haskell"><code>smoothen :: BarkScaledSpectrogram -&gt; SmoothSpectrogram
smoothen (BarkScaledSpectrogram s) =
    SmoothSpectrogram $ fmap (DSP.window (DSP.hanning 1024)) s
</code></pre>
<p>To evaluate loudness we just have to take each of the frequency bands and sum it all:</p>
<p>$$ L_{dB}(t) = \frac{\sum_{k=1}{N}E_k}{N} $$</p>
<p>where \(E_k\) represents the magnitude of the kth frequency band in the spectrogram.
There are \(N\) of them.</p>
<pre class="haskell"><code>loudnessEvaluation :: SmoothSpectrogram -&gt; EventDetectionFunction
loudnessEvaluation (SmoothSpectrogram s) =
    EventDetectionFunction $ result
  where
    freqBandSum k = (foldl (+) 0 k) / (fromIntegral $ length s)
    result = fmap freqBandSum s
</code></pre>
<h2>3. Testing</h2>
<p>We can now proceed to test everything with some sample. Let&#39;s add some utility functions
to load up a <code>wav</code> file:</p>
<pre class="haskell"><code>readWavFile :: String -&gt; IO [Double]
readWavFile fileName = do
    handle &lt;- Snd.openFile fileName Snd.ReadMode Snd.defaultInfo
    (info, Just buf) &lt;- Snd.hGetContents handle :: IO (Snd.Info, Maybe (BV.Buffer Double))
    return (toList $ BV.fromBuffer buf)
  where
    toList = Vector.foldl (\a b -&gt; a ++ [b]) []
</code></pre>
<p>Let&#39;s load our test file:</p>
<pre class="haskell"><code>arrSnd &lt;- readWavFile &quot;resources/heartbeat.wav&quot;
</code></pre>
<p>Now, let&#39;s try plotting the 